
!pip3 install qiskit

First instal Qiskit (above)
then import some useful packages from QIskit (for circuit building and access backend) as well as numpy and pyplot for some mathemtics and visualization:

import qiskit
import matplotlib.pyplot as plt
import matplotlib.axes as axes
%matplotlib inline
import numpy as np
import networkx as nx
from math import pi
from qiskit import Aer
from qiskit.tools.visualization import plot_histogram
from qiskit.circuit.library import TwoLocal

from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit.tools.visualization import circuit_drawer
from qiskit.quantum_info import state_fidelity
from qiskit import BasicAer

%matplotlib inline
# Importing standard Qiskit libraries and configuring account
from qiskit import QuantumCircuit, execute, Aer, IBMQ
from qiskit.compiler import transpile, assemble
from qiskit.tools.jupyter import *
from qiskit.visualization import *


backend = BasicAer.get_backend('unitary_simulator')
from qiskit import *


Here my API token gets loaded to give us access:


IBMQ.save_account('63af478871059f44c837562334bb53037b1591a9140852e357e30b6d30617cb79596f7e6835d571b3374e295446d6222be23ab1ac84d45817eb91a22a23c4ddd')



overwrite=True
IBMQ.load_account()

from qiskit import *
from qiskit.providers.ibmq.exceptions import IBMQAccountCredentialsInvalidToken

Lets take a look at a how Grovers seach algorithm works. 

If you have a list , classically the complexity depends on how many times you need to call the oracle, classically this means atleast N/2  to N. 

However, in the case of Grovers search algorithm, we can reduce the complexity scaling to O(SQRT_N). This is the quadratic speedup promised by QAE.

Grover's aalgorithm has two main components. the first is the oracle, which qeuaries an input state to assertain whether it is the required or expected value, and secondly a reflection operator. The reflection operator is the compoenet that amplifies the amplitude of a specific state:


The oracle:
This is some fucntion/gate that flips the sign of the winning state so that we can identify when we have found it. 
so for exsample, if we have two qubits, we can have the following combinations of vector outputs:

00
01
10
11

and oracle acting on this vector scpae would leave the same except for the final state (11), which would be flipped to give (-11). 
Luckly this is simple for a 2 qubit system where the control Z gate would do just this:


#define the oracle circuit
oracle = QuantumCircuit(2,name ='oracle')
oracle.cz(0,1)
oracle.to_gate()
oracle.draw()

SO lets check this by simply adding a superposition with a Haddamard gate, followed by the CZ gate (oracle):


backend = Aer.get_backend('statevector_simulator')
grover_circ = QuantumCircuit(2,2)
grover_circ.h([0,1])
grover_circ.append(oracle,[0,1])

job = execute(grover_circ,backend)
result = job.result()


sv = result.get_statevector()
np.around(sv,2)
